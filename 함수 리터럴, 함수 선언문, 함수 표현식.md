### 함수 리터럴, 함수 선언문, 함수 표현식

---



#### 1. 함수 리터럴

리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 통해 값을 생성하는 표기 방식이다. 즉, <strong>리터럴은 값이다.</strong> 

함수 리터럴도 마찬가지로 평가되어 값을 생성하며, 이 값은 객체이다.

```javascript
// 변수 f에 함수 리터럴을 할당

var f = function add(x, y) {
	return x + y;
}
```



#### 2. 함수 선언문

자바스크립트에는 함수를 정의하는 방법이 4가지가 있다. 그 첫번째로 함수 선언문을 알아보자.



```javascript
// 함수 선언문

function add(x, y) {
	return x + y;
}
```

함수 선언문을 보면 방금 전 보았던 함수 리터럴과 형태가 똑같다. 하지만 중요한 차이점이 몇가지 있다.

* 함수 선언문은 함수 이름을 생략할 수 없고, 함수 리터럴은 이름을 생략할 수 있다.

* 함수 선언문은 <strong>표현식이 아닌 문</strong>이고, 함수 리터럴은 표현식이다. 그런데 아래 예시를 보면, 표현식이 아닌 문에 해당하는 함수 선언문을 변수에 할당하고 있다.

  ```javascript
  var add = function addNumbers(x, y) {
  	return x + y;
  }
  ```

  표현식이 아닌 문은 값으로 평가되지 않기 때문에 변수에 할당할 수 없다.

  하지만, 위 예제에서는 함수 선언문이 아니라 함수 리터럴로 해석되었기 때문에 변수에 할당이 가능하다.

  자바스크립트는 문맥에 따라서 코드를 해석한다. 가령, '{}'은 객체로 해석될 때도 있지만 코드 블럭으로 해석되기도 한다.

  

  이번에는 반대로 리터럴 표현식이 아닌 선언문으로 해석되는 경우를 보자.

  ```javascript
  function foo() { console.log('foo')}
  ```

  기명 함수 리터럴이 단독으로 쓰이면 자바스크립트 엔진은 이를 함수 선언문으로 해석한다.

  

  헷갈릴 수 있으니 예제를 하나 더 보자

  ```javascript
  (function bar() { console.log('bar')})
  
  bar(); // 호출이 안되면: 리터럴임, 호출이 되면 선언식임.
  ```

  이번에는 함수 리터럴 표현식으로 해석된다. 왜냐하면 ()이라는 그룹 연산자로 묶여 있기 때문이다.

  그리고 bar()를 통해 함수를 호출해도 에러가 발생한다. 왜냐하면 <strong>함수 리터럴의 함수 이름은 함수 몸체 내에서만 참조할 수 있기 때문이다.</strong>



* 함수 선언문도 함수 표현식으로 구성되어 있는데, 왜 정상적으로 호출이 될까?

  이는 함수 선언문을 해석할 때 <strong>자바스크립트 엔진이 암묵적으로 식별자를 생성하고 함수를 해당 식별자에 할당하기 때문이다.</strong>

  ```javascript
  function add (x, y) {
  	return x + y;
  }
  
  ```
  
  위 예제에서는 add 라는 식별자를 새로이 생성하고 에 함수 객체를 할당하게 된다. 따라서, 외부에서 add()를 통해 함수를 호출할 수 있다.



#### 3. 함수 표현식

<strong>함수 리터럴로 생성한 함수 객체는 변수에 할당할 수 있다.</strong> 이와 같은 함수 정의 방식을 함수 표현식이라고 한다.

```javascript
var add = function (x, y) {
	return x + y;
};
```

함수 표현식을 보면, 함수 선언문이 자바스크립트 엔진에 의해 해석되어 정의되는 과정과 동일해 보인다.

하지만 중요한 차이점이 있다.



#### 4. 호이스팅

```javascript
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError

// add 변수를 만들고, 함수를 거기에 할당
function add (x, y) {
    return x + y;
}

var sub = function (x, y) {
    return x - y;
}
```

동작 과정을 하나식 살펴보자

* add 변수에는 코드가 실행되는 시점에 이미 함수 객체가 할당되었다. 따라서, 함수 선언문 이전에 함수를 호출했음에도 정상적으로 실행된다.
* sub는 var로 만든 변수이기 때문에 변수 호이스팅으로 인해 '선언'은 되었다. 하지만, 함수 객체가 할당되지는 않는다. 변수 호이스팅과 함수 호이스팅의 차이가 바로 여기에 있다.

* 결론적으로 함수 호이스팅은 함수를 호출하기 전에 함수를 선언해야 한다는 당연한 규칙을 무시한다. 따라서, 함수 선언문 대신 함수 표현식을 사용할 것을 권장한다.

  (내가 아니라, JSON을 창안한 더글라스 크락포드가..)





